def subsitute(expr,value,x):
    #N
    if(case(expr,Foundation.N)):
        return expr
    #B
    elif(case(expr,Foundation.B)):
        return expr
    #S
    elif(case(expr,Foundation.S)):
        return expr
    #Null
    elif(case(expr,Foundation.Null)):
        return expr
    #Var
    elif(case(expr,Foundation.Var)):
        if(x == expr.X()):
            return value
        else:
            return expr
    #Array
    elif(case(expr,Foundation.Array)):
        subArray = []
        for i in range(0,len(expr.expr1())):
            subArray.append(subsitute(expr.expr1()[i],value,x))
        return Foundation.Array(subArray)
    #Binary
    elif(case(expr,Foundation.Binary)):
        return Foundation.Binary(expr.bop(),subsitute(expr.expr1(),value,x),subsitute(expr.expr2(),value,x))

    #Eq
    elif(case(expr,Foundation.Eq)):
        return Foundation.Eq(subsitute(expr.expr1(),value,x),subsitute(expr.expr2(),value,x))
    #Ne
    elif(case(expr,Foundation.Ne)):
        return Foundation.Ne(subsitute(expr.expr1(),value,x),subsitute(expr.expr2(),value,x))
    #Lt
    elif(case(expr,Foundation.Lt)):
        return Foundation.Lt(subsitute(expr.expr1(),value,x),subsitute(expr.expr2(),value,x))
    #Le
    elif(case(expr,Foundation.Le)):
        return Foundation.Le(subsitute(expr.expr1(),value,x),subsitute(expr.expr2(),value,x))
    #Ge
    elif(case(expr,Foundation.Ge)):
        return Foundation.Ge(subsitute(expr.expr1(),value,x),subsitute(expr.expr2(),value,x))
    #Gt
    elif(case(expr,Foundation.Gt)):
        return Foundation.Gt(subsitute(expr.expr1(),value,x),subsitute(expr.expr2(),value,x))
    #Or
    elif(case(expr,Foundation.Or)):
        return Foundation.Or(subsitute(expr.expr1(),value,x),subsitute(expr.expr2(),value,x))
    #And
    elif(case(expr,Foundation.And)):
        return Foundation.And(subsitute(expr.expr1(),value,x),subsitute(expr.expr2(),value,x))
    #If
    elif(case(expr,Foundation.If)):
        return Foundation.If(subsitute(expr.expr1(),value,x),subsitute(expr.expr2(),value,x),subsitute(expr.expr3(),value,x))
    #Seq
    elif(case(expr,Foundation.Seq)):
        e1 = subsitute(expr.expr1(),value,x)
        e2 = subsitute(expr.expr2(),value,x)
        return Foundation.Seq(e1,e2)
    #Call
    elif(case(expr,Foundation.Call)):#Extend list to allow recursion
        sbtBody = subsitute(expr.expr2(),value,x)
        sbtArg = []
        for i in range(0,len(expr.expr1())):
            sbtArg.append(subsitute(expr.expr1()[i],value,x))
        return Foundation.Call(sbtArg,sbtBody)
    #Return
    elif(case(expr,Foundation.Return)):
        return Foundation.Return(subsitute(expr.expr1(),value,x))
    #print
    elif(case(expr,Foundation.Print)):
        return Foundation.Print(subsitute(expr.E(),value,x))
    #Malloc
    elif(case(expr,Foundation.Malloc)):
        return Foundation.Malloc("Var",expr.expr2(),subsitute(expr.expr3(),value,x))
    #Index
    elif(case(expr, Foundation.Index)):
        return Foundation.Index(subsitute(expr.expr1(),value,x),subsitute(expr.expr2(),value,x))
    elif(case(expr,Foundation.Assign)):
        if(case(expr.expr1(),Foundation.Index)):
            return Foundation.Assign(subsitute(expr.expr1(),value,x),subsitute(expr.expr2(),value,x))
        return Foundation.Assign(expr.expr1(),subsitute(expr.expr2(),value,x))
    elif(case(expr,Foundation.For)):
        return Foundation.For(subsitute(expr.expr1(),value,x),subsitute(expr.expr2(),value,x),subsitute(expr.expr3(),value,x),subsitute(expr.expr4(),value,x))
    else:
        print(expr)
        print("Uncaught subsitute")